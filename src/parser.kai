#import "lexer.kai" lex
#import "alloc.kai"
#import "ast.kai"
#import "errors.kai"
#import "strings.kai"

#import "libc.kai"

LowestPrecedence  :: 0
UnaryPrecedence   :: 7
HighestPrecedence :: 8

DefaultListLen :: 10

AstNode :: *ast.AstNode

SourceFile :: struct {
    arena: alloc.Arena
    fullpath: string
    lexer: lex.Lexer
    tokens: []lex.Token
    tokenIndex: u64
    currentToken: lex.Token
}

SourcePackage :: struct {
    initPath: string
    files: []*SourceFile
    totalLineCount: u64
}

SourceFileInit :: fn(file: *SourceFile, path: string) -> bool {
    lexer: lex.Lexer
    ok := lex.LexerInit(&lexer, path)
    if !ok
        return false

    allocator := alloc.DefaultAllocatorInit()
    alloc.ArrayInit(allocator, &file.tokens, lexer.data.len)

    for true {
        tok := lex.NextToken(&lexer)
        alloc.Append(allocator, &file.tokens, tok)

        libc.printf("token: \x1b[35m%s\x1b[0m, lit: \x1b[34m\"%.*s\"\x1b[0m\n".raw, lex.Describe(tok).raw, tok.lit.len, tok.lit.raw)

        if tok.kind == lex.TokenKind.Eof
            break
    }

    file.fullpath = path
    alloc.ArenaInit(&file.arena, sizeof(ast.AstNode) * lexer.data.len)

    // load the first token
    next(file)

    return true
}

MakeNode :: fn(f: *SourceFile, kind: ast.AstKind) -> AstNode {
    using alloc
    arena := &f.arena
    node := cast(AstNode)Alloc(ArenaAllocatorInit(arena), sizeof(ast.AstNode))
    node.kind = kind
    return node
}


MakeBadExpr :: fn(f: *SourceFile, begin, end: lex.Token) -> AstNode {
    node := MakeNode(f, ast.AstKind.BadExpr)
    node.ast.BadExpr.begin = begin
    node.ast.BadExpr.end = end
    return node
}

MakeNilLiteral :: fn(f: *SourceFile, token: lex.Token) -> AstNode {
    node := MakeNode(f, ast.AstKind.NilLiteral)
    node.ast.NilLiteral = token
    return node
}

MakeIdent :: fn(f: *SourceFile, token: lex.Token) -> AstNode {
    node := MakeNode(f, ast.AstKind.Ident)
    node.ast.Ident = token
    return node
}

MakeEllipsis :: fn(f: *SourceFile, expr: AstNode, token: lex.Token) -> AstNode {
    node := MakeNode(f, ast.AstKind.Ellipsis)
    node.ast.Ellipsis.expr = expr
    node.ast.Ellipsis.token = token
    return node
}

MakeBasicLit :: fn(f: *SourceFile, token: lex.Token) -> AstNode {
    node := MakeNode(f, ast.AstKind.BasicLit)
    node.ast.BasicLit = token
    return node
}

MakeIdentList :: fn(f: *SourceFile, token: lex.Token, idents: []AstNode) -> AstNode {
    node := MakeNode(f, ast.AstKind.IdentList)
    node.ast.IdentList.token = token
    node.ast.IdentList.idents = idents
    return node
}

MakeFuncLit :: fn(f: *SourceFile, token: lex.Token, type, body: AstNode) -> AstNode {
    node := MakeNode(f, ast.AstKind.FuncLit)
    node.ast.FuncLit.token = token
    node.ast.FuncLit.type = type
    node.ast.FuncLit.body = body
    return node
}

MakeCompositeLit :: fn(f: *SourceFile, begin, end: lex.Token, elements: []AstNode) -> AstNode {
    node := MakeNode(f, ast.AstKind.CompositeLit)
    node.ast.CompositeLit.begin = begin
    node.ast.CompositeLit.end = end
    node.ast.CompositeLit.elements = elements
    return node
}

MakeParen :: fn(f: *SourceFile, begin, end: lex.Token, expr: AstNode) -> AstNode {
    node := MakeNode(f, ast.AstKind.Paren)
    node.ast.Paren.begin = begin
    node.ast.Paren.end = end
    node.ast.Paren.expr = expr
    return node
}

MakeSelector :: fn(f: *SourceFile, token: lex.Token, rec, sel: AstNode) -> AstNode {
    node := MakeNode(f, ast.AstKind.Selector)
    node.ast.Selector.token = token
    node.ast.Selector.rec = rec
    node.ast.Selector.sel = sel
    return node
}

MakeSubscript :: fn(f: *SourceFile, begin, end: lex.Token, rec, index: AstNode) -> AstNode {
    node := MakeNode(f, ast.AstKind.Subscript)
    node.ast.Subscript.begin = begin
    node.ast.Subscript.end = end
    node.ast.Subscript.rec = rec
    node.ast.Subscript.index = index
    return node
}

MakeSlice :: fn(f: *SourceFile, begin, end: lex.Token, expr, hi, lo: AstNode) -> AstNode {
    node := MakeNode(f, ast.AstKind.Slice)
    node.ast.Slice.begin = begin
    node.ast.Slice.end = end
    node.ast.Slice.expr = expr
    node.ast.Slice.hi = hi
    node.ast.Slice.lo = lo
    return node
}

MakeAutocast :: fn(f: *SourceFile, token: lex.Token, expr: AstNode) -> AstNode {
    node := MakeNode(f, ast.AstKind.Autocast)
    node.ast.Autocast.token = token
    node.ast.Autocast.expr = expr
    return node
}

MakeCast :: fn(f: *SourceFile, kind: lex.Token, type, expr: AstNode) -> AstNode {
    node := MakeNode(f, ast.AstKind.Cast)
    node.ast.Cast.kind = kind
    node.ast.Cast.type = type
    node.ast.Cast.expr = expr
    return node
}

MakeCall :: fn(f: *SourceFile, begin, end: lex.Token, labels, args: []AstNode) -> AstNode {
    node := MakeNode(f, ast.AstKind.Call)
    node.ast.Call.begin = begin
    node.ast.Call.end = end
    node.ast.Call.labels = labels
    node.ast.Call.args = args
    return node
}

MakeUnary :: fn(f: *SourceFile, op: lex.Token, element: AstNode) -> AstNode {
    node := MakeNode(f, ast.AstKind.Unary)
    node.ast.Unary.op = op
    node.ast.Unary.kind = tokenOperator(op)
    node.ast.Unary.element = element
    return node
}

MakeBinary :: fn(f: *SourceFile, op: lex.Token, lhs, rhs: AstNode) -> AstNode {
    node := MakeNode(f, ast.AstKind.Binary)
    node.ast.Binary.op = op
    node.ast.Binary.kind = tokenOperator(op)
    node.ast.Binary.lhs = lhs
    node.ast.Binary.rhs = rhs
    return node
}

MakeTernary :: fn(f: *SourceFile, qmark, colon: lex.Token, cond, then, els: AstNode) -> AstNode {
    node := MakeNode(f, ast.AstKind.Ternary)
    node.ast.Ternary.qmark = qmark
    node.ast.Ternary.colon = colon
    node.ast.Ternary.cond = cond
    node.ast.Ternary.then = then
    node.ast.Ternary.els = els
    return node
}

MakeKeyValue :: fn(f: *SourceFile, token: lex.Token, key, value: AstNode) -> AstNode {
    node := MakeNode(f, ast.AstKind.KeyValue)
    node.ast.KeyValue.token = token
    node.ast.KeyValue.key = key
    node.ast.KeyValue.value = value
    return node
}

MakePointerType :: fn(f: *SourceFile, token: lex.Token, type: AstNode) -> AstNode {
    node := MakeNode(f, ast.AstKind.PointerType)
    node.ast.PointerType.token = token
    node.ast.PointerType.type = type
    return node
}

MakeArrayType :: fn(f: *SourceFile, begin, end: lex.Token, length, type: AstNode) -> AstNode {
    node := MakeNode(f, ast.AstKind.ArrayType)
    node.ast.ArrayType.begin = begin
    node.ast.ArrayType.end = end
    node.ast.ArrayType.length = length
    node.ast.ArrayType.type = type
    return node
}

MakeSliceType :: fn(f: *SourceFile, begin, end: lex.Token, type: AstNode) -> AstNode {
    node := MakeNode(f, ast.AstKind.SliceType)
    node.ast.SliceType.begin = begin
    node.ast.SliceType.end = end
    node.ast.SliceType.type = type
    return node
}

MakeVectorType :: fn(f: *SourceFile, begin, end: lex.Token, size, type: AstNode) -> AstNode {
    node := MakeNode(f, ast.AstKind.VectorType)
    node.ast.VectorType.begin = begin
    node.ast.VectorType.end = end
    node.ast.VectorType.size = size
    node.ast.VectorType.type = type
    return node
}

MakePolyType :: fn(f: *SourceFile, token: lex.Token, type: AstNode) -> AstNode {
    node := MakeNode(f, ast.AstKind.PolyType)
    node.ast.PolyType.token = token
    node.ast.PolyType.type = type
    return node
}

MakeVariadicType :: fn(f: *SourceFile, token: lex.Token, type: AstNode, isCVargs: bool) -> AstNode {
    node := MakeNode(f, ast.AstKind.VariadicType)
    node.ast.VariadicType.token = token
    node.ast.VariadicType.type = type
    node.ast.VariadicType.isCVargs = isCVargs
    return node
}

MakeBadStmt :: fn(f: *SourceFile, begin, end: lex.Token) -> AstNode {
    node := MakeNode(f, ast.AstKind.BadStmt)
    node.ast.BadStmt.begin = begin
    node.ast.BadStmt.end = end
    return node
}

MakeEmpty :: fn(f: *SourceFile, token: lex.Token) -> AstNode {
    node := MakeNode(f, ast.AstKind.Empty)
    node.ast.Empty = token
    return node
}

MakeLabel :: fn(f: *SourceFile, token: lex.Token) -> AstNode {
    node := MakeNode(f, ast.AstKind.Label)
    node.ast.Label = token
    return node
}

MakeExprStmt :: fn(f: *SourceFile, token: lex.Token, expr: AstNode) -> AstNode {
    node := MakeNode(f, ast.AstKind.ExprStmt)
    node.ast.ExprStmt.token = token
    node.ast.ExprStmt.expr = expr
    return node
}

MakeAssign :: fn(f: *SourceFile, token: lex.Token, lhs, rhs: []AstNode) -> AstNode {
    node := MakeNode(f, ast.AstKind.Assign)
    node.ast.Assign.token = token
    node.ast.Assign.lhs = lhs
    node.ast.Assign.rhs = rhs
    return node
}

MakeReturn :: fn(f: *SourceFile, token: lex.Token, stmts: []AstNode) -> AstNode {
    node := MakeNode(f, ast.AstKind.Return)
    node.ast.Return.token = token
    node.ast.Return.stmts = stmts
    return node
}

MakeDefer :: fn(f: *SourceFile, token: lex.Token, stmt: AstNode) -> AstNode {
    node := MakeNode(f, ast.AstKind.Defer)
    node.ast.Defer.token = token
    node.ast.Defer.stmt = stmt
    return node
}

MakeUsing :: fn(f: *SourceFile, token: lex.Token, expr: AstNode) -> AstNode {
    node := MakeNode(f, ast.AstKind.Using)
    node.ast.Using.token = token
    node.ast.Using.expr = expr
    return node
}

MakeBranch :: fn(f: *SourceFile, token: lex.Token, label: AstNode) -> AstNode {
    node := MakeNode(f, ast.AstKind.Branch)
    node.ast.Branch.token = token
    node.ast.Branch.label = label
    return node
}

MakeBlock :: fn(f: *SourceFile, begin, end: lex.Token, stmts: []AstNode) -> AstNode {
    node := MakeNode(f, ast.AstKind.Block)
    node.ast.Block.begin = begin
    node.ast.Block.end = end
    node.ast.Block.stmts = stmts
    return node
}

MakeIf :: fn(f: *SourceFile, token: lex.Token, cond, body, els: AstNode) -> AstNode {
    node := MakeNode(f, ast.AstKind.If)
    node.ast.If.token = token
    node.ast.If.cond = cond
    node.ast.If.body = body
    node.ast.If.els = els
    return node
}

MakeCaseClause :: fn(f: *SourceFile, token: lex.Token, match: []AstNode, block: AstNode) -> AstNode {
    node := MakeNode(f, ast.AstKind.CaseClause)
    node.ast.CaseClause.token = token
    node.ast.CaseClause.match = match
    node.ast.CaseClause.block = block
    return node
}

MakeSwitch :: fn(f: *SourceFile, token: lex.Token, match: AstNode, cases: []AstNode) -> AstNode {
    node := MakeNode(f, ast.AstKind.Switch)
    node.ast.Switch.token = token
    node.ast.Switch.match = match
    node.ast.Switch.cases = cases
    return node
}

MakeFor :: fn(f: *SourceFile, token: lex.Token, init, cond, step, body: AstNode) -> AstNode {
    node := MakeNode(f, ast.AstKind.For)
    node.ast.For.token = token
    node.ast.For.init = init
    node.ast.For.cond = cond
    node.ast.For.step = step
    node.ast.For.body = body
    return node
}

MakeLibrary :: fn(f: *SourceFile, token: lex.Token, path, alias: AstNode) -> AstNode {
    node := MakeNode(f, ast.AstKind.Library)
    node.ast.Library.token = token
    node.ast.Library.path = path
    node.ast.Library.alias = alias
    return node
}

MakeForeign :: fn(f: *SourceFile, token: lex.Token, library, decl: AstNode, linkname, callconv: []u8) -> AstNode {
    node := MakeNode(f, ast.AstKind.Foreign)
    node.ast.Foreign.token = token
    node.ast.Foreign.library = library
    node.ast.Foreign.decl = decl
    node.ast.Foreign.linkname = linkname
    node.ast.Foreign.callconv = callconv
    return node
}

MakeDeclaration :: fn(f: *SourceFile, token: lex.Token, names, values: []AstNode, type: AstNode, isConstant: bool) -> AstNode {
    node := MakeNode(f, ast.AstKind.Declaration)
    node.ast.Declaration.token = token
    node.ast.Declaration.names = names
    node.ast.Declaration.values = values
    node.ast.Declaration.type = type
    node.ast.Declaration.isConstant = isConstant
    return node
}

MakeBadDecl :: fn(f: *SourceFile, begin, end: lex.Token) -> AstNode {
    node := MakeNode(f, ast.AstKind.BadDecl)
    node.ast.BadDecl.begin = begin
    node.ast.BadDecl.end = end
    return node
}

next0 :: fn(f: *SourceFile) -> void {
    if f.tokenIndex+1 >= f.tokens.len {
        // TODO(Brett): error
        return
    }

    f.currentToken = f.tokens[f.tokenIndex]
    f.tokenIndex += 1
}

next :: fn(f: *SourceFile) -> lex.Token {
    prev := f.currentToken
    next0(f)
    for f.currentToken.kind == lex.TokenKind.Comment {
        next0(f)
    }

    return prev
}

parseIdent :: fn(f: *SourceFile) -> AstNode {
    token := f.currentToken
    if token.kind == lex.TokenKind.Ident {
        next(f)
    } else {
        token.lit = "_"
    }

    return MakeIdent(f, token)
}

parseElement :: fn(f: *SourceFile) -> AstNode {
    if f.currentToken.kind == lex.TokenKind.Lbrace {
        return MakeKeyValue(f, f.currentToken, nil, parseCompositeLiteralBody(f, nil))
    }

    el := parseExpr(f, false)
    if f.currentToken.kind == lex.TokenKind.Colon {
        colon := next(f)
        return MakeKeyValue(f, colon, el, parseExpr(f, false))
    }

    return MakeKeyValue(f, f.currentToken, nil, el)
}

parseElementList :: fn(f: *SourceFile) -> []AstNode {
    elements := []AstNode {}
    allocator := alloc.DefaultAllocatorInit()
    alloc.ArrayInit(allocator, &elements, DefaultListLen)

    for f.currentToken.kind != lex.TokenKind.Rbrace && f.currentToken.kind != lex.TokenKind.Eof {
        alloc.Append(allocator, &elements, parseElement(f))
        if !atComma(f, lex.TokenKind.Rbrace, "composite literal")
            break

        next(f)
    }

    return elements
}

parseCompositeLiteralBody :: fn(f: *SourceFile, type: AstNode) -> AstNode {
    begin := next(f)
    elements := parseElementList(f)
    end := expect(f, lex.TokenKind.Rbrace)
    return MakeCompositeLit(f, begin, end, elements)
}

parseOperand :: fn(f: *SourceFile, allowPolyOrVariadicType: bool) -> AstNode {
    switch using f.currentToken.kind {
    case Nil:
        return MakeNilLiteral(f, next(f))
    case Ident:
        return parseIdent(f)
    case String, Int, Float:
        return MakeBasicLit(f, next(f))
    case Fn:
        token := next(f)
        type := parseFuncType(f, false)
        body := parseBlock(f)
        return MakeFuncLit(f, token, type, body)
    case Cast, Bitcast:
        kind := next(f)
        expect(f, lex.TokenKind.Lparen)
        explicitType := parseType(f, false, false)
        expect(f, lex.TokenKind.Rparen)
        expr := parseUnaryExpr(f, false)
        return MakeCast(f, kind, explicitType, expr)
    case Autocast:
        token := next(f)
        expr := parseUnaryExpr(f, false)
        return MakeAutocast(f, token, expr)
    case Lparen:
        return parseFuncType(f, true)
    }

    return parseType(f, allowPolyOrVariadicType, allowPolyOrVariadicType)
}

parseStmts :: fn(f: *SourceFile) -> []AstNode {
    stmts := []AstNode {}
    allocator := alloc.DefaultAllocatorInit()
    alloc.ArrayInit(allocator, &stmts, DefaultListLen)

    for f.currentToken.kind != lex.TokenKind.Eof {
        alloc.Append(allocator, &stmts, parseStmt(f))
    }

    return stmts
}

parseStmtList :: fn(f: *SourceFile) -> []AstNode {
    stmts: []AstNode
    allocator := alloc.DefaultAllocatorInit()
    alloc.ArrayInit(allocator, &stmts, DefaultListLen)

    using lex.TokenKind
    alloc.Append(allocator, &stmts, parseStmt(f))
    for f.currentToken.kind != Case && f.currentToken.kind != Rbrace && f.currentToken.kind != Eof {
        alloc.Append(allocator, &stmts, parseStmt(f))
    }

    return stmts
}

parseStmt :: fn(f: *SourceFile) -> AstNode {
    switch using f.currentToken.kind {
    case Ident, Int, Float, String, Fn, Lparen,
         Lbrack, Struct, Union, Enum,
         Add, Sub, Mul, And, Xor, Not, Lss:
        stmt := parseSimpleStmt(f)
        expectTerm(f)
        return stmt

    case Break, Continue, Goto, Fallthrough:
        token := next(f)
        label : AstNode = nil
        if f.currentToken.kind != Fallthrough && f.currentToken.kind == Ident {
            label = parseIdent(f)
        }

        expectTerm(f)
        return MakeBranch(f, token, label)
    case Lbrace:
        block := parseBlock(f)
        if f.currentToken.kind != Else
            expectTerm(f)
        return block
    case Rbrace:
        // NOTE: don't move the token forward
        return MakeEmpty(f, f.currentToken)
    case If:
        token := next(f)
        cond := parseExpr(f, false)
        allowTerm(f)
        body := parseStmt(f)
        els : AstNode = nil
        if f.currentToken.kind == Else {
            next(f)
            els = parseStmt(f)
        }
        return MakeIf(f, token, cond, body, els)
    case Switch:
        return parseSwitchStmt(f)
    case For:
        return parseForStmt(f)
    case Return:
        token := next(f)
        x := []AstNode {}
        if f.currentToken.kind != Semicolon && f.currentToken.kind != Rbrace
            x = parseExprList(f)
        expectTerm(f)
        return MakeReturn(f, token, x)
    case Using:
        token := next(f)
        expr := parseExpr(f, false)
        allowTerm(f)
        return MakeUsing(f, token, expr)
    case Defer:
        token := next(f)
        stmt := parseStmt(f)
        return MakeDefer(f, token, stmt)
    }

    // TODO(Brett): error and recover
    begin := next(f)
    return MakeBadStmt(f, begin, begin)
}

parseSimpleStmt :: fn(f: *SourceFile) -> AstNode {
    x := parseExprList(f)

    switch using f.currentToken.kind {
    case Assign:
        token := next(f)
        rhs := parseExprList(f)
        return MakeAssign(f, token, x, rhs)
    case AssignAdd, AssignSub, AssignMul, AssignQuo, AssignRem,
         AssignAnd, AssignOr,  AssignXor, AssignShl, AssignShr:
        token := next(f)
        rhs := parseExprList(f)
        if rhs.len > 1 || x.len > 1 {
            // TODO(Brett): error: Assignment macros only permit a single values
        }

        operation := MakeBinary(f, token, x[0], rhs[0])
        return MakeAssign(f, token, x, stmtToStmtList(operation))
    case Colon:
        token := next(f)
        if x.len == 1 && x[0].kind == ast.AstKind.Ident && f.currentToken.kind == Semicolon && strings.Compare(f.currentToken.lit, "\n") {
            // NOTE: Ident and Label are both just tokens
            label := x[0]
            label.kind = ast.AstKind.Label
            return label
        }

        // TODO(Brett): ensure that all elements in 'x' are Ident
        if f.currentToken.kind == Assign {
            token := next(f)
            values := parseExprList(f)
            return MakeDeclaration(f, token, x, values, nil, false)
        } else if f.currentToken.kind == Colon {
            token := next(f)
            values := parseExprList(f)
            return MakeDeclaration(f, token, x, values, nil, true)
        }

        type := parseType(f, false, false)
        switch f.currentToken.kind {
        case Assign:
            token := next(f)
            values := parseExprList(f)
            return MakeDeclaration(f, token, x, values, type, false)
        case Colon:
            token := next(f)
            values := parseExprList(f)
            return MakeDeclaration(f, token, x, values, type, true)
        case:
            return MakeDeclaration(f, token, x, []AstNode{}, type, false)
        }
    case In:
        return MakeIdentList(f, f.currentToken, x)
    }

    if x.len > 1 {
        // TODO(Brett): error: expected one expression"
    }

    return MakeExprStmt(f, x[0].ast.Ident, x[0])
}

parseSwitchStmt :: fn(f: *SourceFile) -> AstNode {
    using lex.TokenKind

    token := expect(f, Switch)
    match : AstNode = nil
    if f.currentToken.kind != Lbrace && f.currentToken.kind != Semicolon {
        match = parseExpr(f, false)
    }

    if f.currentToken.kind == Semicolon
        next(f)

    expect(f, Lbrace)

    cases: []AstNode
    allocator := alloc.DefaultAllocatorInit()
    alloc.ArrayInit(allocator, &cases, DefaultListLen)

    alloc.Append(allocator, &cases, parseExpr(f, false))
    for f.currentToken.kind == Case {
        alloc.Append(allocator, &cases, parseCaseClause(f))
    }

    expect(f, Rbrace)
    expectTerm(f)
    return MakeSwitch(f, token, match, cases)
}

parseCaseClause :: fn(f: *SourceFile) -> AstNode {
    token := next(f)
    match := []AstNode {}
    if f.currentToken.kind != lex.TokenKind.Colon
        match = parseExprList(f)

    colon := expect(f, lex.TokenKind.Colon)
    body := parseStmtList(f)
    // TODO(Brett): fix block tokens
    block := MakeBlock(f, colon, colon, body)
    return MakeCaseClause(f, token, match, block)
}

parseForStmt :: fn(f: *SourceFile) -> AstNode {
    token := next(f)
    s1, s2, s3: AstNode = nil, nil, nil
    using lex.TokenKind

    if f.currentToken.kind == Lbrace && f.currentToken.kind != Semicolon {
        s2 = parseSimpleStmt(f)
        if s2.kind == ast.AstKind.IdentList {
            // TODO(Brett): forin
        }
    }

    if f.currentToken.kind == Semicolon && !strings.Compare(f.currentToken.lit, "{") {
        next(f)
        s1 = s2
        s2 = nil
        if f.currentToken.kind != Semicolon
            s2 = parseSimpleStmt(f)

        expectTerm(f)
        if f.currentToken.kind != Lbrace && !(f.currentToken.kind == Semicolon && strings.Compare(f.currentToken.lit, "{")) {
            s3 = parseSimpleStmt(f)
        }
    }

    expectTerm(f)
    body := parseBlock(f)
    expectTerm(f)

    // TODO(Brett): ensure that s2 is an expression or nil
    return MakeFor(f, token, s1, s2, s3, body)
}

// TODO(Brett): struct, union, variant, enum
parseType :: fn(f: *SourceFile, allowPoly, allowVariadic: bool) -> AstNode {
    switch using f.currentToken.kind {
    case Ident:
        x := parseIdent(f)
        if f.currentToken.kind == Period {
            tok := next(f)
            return MakeSelector(f, tok, x, parseIdent(f))
        }
        return x
    case Lbrack:
        lbrack := next(f)

        isVector := false
        isImplicitlySized := false
        length: AstNode

        switch f.currentToken.kind {
        case Rbrack:
            length = nil
        case Ellipsis:
            next(f)
            length = nil
            isImplicitlySized = true
        case Ident:
            if !strings.Compare(f.currentToken.lit, "vec")
                fallthrough
            next(f)
            isVector = true
            length = parseExpr(f, false)
        case:
            length = parseExpr(f, false)
        }

        rbrack := expect(f, Rbrack)
        type := parseType(f, false, false)

        if length != nil {
            if isVector
                return MakeVectorType(f, lbrack, rbrack, length, type)
            return MakeArrayType(f, lbrack, rbrack, length, type)
        } else if isImplicitlySized {
            return MakeArrayType(f, lbrack, rbrack, nil, type)
        } else {
            return MakeSliceType(f, lbrack, rbrack, type)
        }
    case Mul:
        token := next(f)
        return MakePointerType(f, token, parseType(f, false, false))
    case Lparen:
        return parseFuncType(f, false)
    case Dollar:
        token := next(f)
        type := parseType(f, false, false)
        return MakePolyType(f, token, type)
    case Ellipsis:
        if !allowVariadic
            break

        ellipsis := next(f)
        return MakeVariadicType(f, ellipsis, parseType(f, true, false), false)
    case Directive:
        if !allowVariadic || !strings.Compare(f.currentToken.lit, "cvargs") {
            break
        }

        next(f)
        ellipsis := expect(f, lex.TokenKind.Ellipsis)
        return MakeVariadicType(f, ellipsis, parseType(f, true, false), true)
    }

    // TODO(Brett): error and recover
    begin := next(f)
    return MakeBadStmt(f, begin, begin)
}

parseFuncType :: fn(f: *SourceFile, allowParenthesizedExpr: bool) -> AstNode {
    return nil
}

parseBlock :: fn(f: *SourceFile) -> AstNode {
    begin := next(f)
    stmts := []AstNode {}

    if f.currentToken.kind != lex.TokenKind.Rbrace {
        stmts = parseStmtList(f)
    }

    end := expect(f, lex.TokenKind.Rbrace)
    return MakeBlock(f, begin, end, stmts)
}

parseExpr :: fn(f: *SourceFile, allowPolyOrVariadicType: bool) -> AstNode {
    return parseBinaryExpr(f, LowestPrecedence + 1, allowPolyOrVariadicType)
}

parseExprList :: fn(f: *SourceFile) -> []AstNode {
    list: []AstNode
    allocator := alloc.DefaultAllocatorInit()
    alloc.ArrayInit(allocator, &list, DefaultListLen)

    using lex.TokenKind
    alloc.Append(allocator, &list, parseExpr(f, false))
    for f.currentToken.kind == Comma {
        next(f)
        alloc.Append(allocator, &list, parseExpr(f, false))
    }

    return list
}

parseArgumentList :: fn(f: *SourceFile) -> []AstNode, []AstNode {
    allocator := alloc.DefaultAllocatorInit()

    labels: []AstNode
    exprs:  []AstNode

    alloc.ArrayInit(allocator, &labels, DefaultListLen)
    alloc.ArrayInit(allocator, &exprs,  DefaultListLen)

    using lex.TokenKind
    for true {
        label: AstNode = nil
        expr := parseExpr(f, false)
        if expr.kind == ast.AstKind.Ident && f.currentToken.kind == Colon {
            next(f)
            label = expr
            expr = parseExpr(f, false)
        }

        alloc.Append(allocator, &labels, label)
        alloc.Append(allocator, &exprs,  expr)

        if f.currentToken.kind != Comma
            break

        next(f)
    }

    return labels, exprs
}

parseUnaryExpr :: fn(f: *SourceFile, allowPolyOrVariadicType: bool) -> AstNode {
    switch using f.currentToken.kind {
    case Add, Sub, Not, Xor, And, Lss:
        op := next(f)
        expr := parseUnaryExpr(f, false)
        return MakeUnary(f, op, expr)
    case Mul:
        token := next(f)
        return MakePointerType(f, token, parseType(f, false, false))
    case:
        return parsePrimaryExpr(f, allowPolyOrVariadicType)
    }
}

parseBinaryExpr :: fn(f: *SourceFile, prec: u64, allowPolyOrVariadicType: bool) -> AstNode {
    lhs := parseUnaryExpr(f, allowPolyOrVariadicType)

    for true {
        op := f.currentToken
        oprec := tokenPrecedence(f)
        if oprec < prec
            return lhs

        next(f)
        rhs := parseBinaryExpr(f, oprec + 1, false)
        lhs = MakeBinary(f, op, lhs, rhs)
    }
}

parsePrimaryExpr :: fn(f: *SourceFile, allowPolyOrVariadicType: bool) -> AstNode {
    x := parseOperand(f, allowPolyOrVariadicType)

    for true {
        switch using f.currentToken.kind {
        case Period:
            token := next(f)
            x = MakeSelector(f, token, x, parseIdent(f))
        case Lbrack:
            begin := next(f)
            if f.currentToken.kind == Colon {
                next(f)
                if f.currentToken.kind == Rbrack {
                    end := next(f)
                    x = MakeSlice(f, begin, end, x, nil, nil)
                    break
                }

                hi := parseExpr(f, false)
                end := expect(f, Rbrack)
                x = MakeSlice(f, begin, end, x, nil, hi)
                break
            }

            index := parseExpr(f, false)
            if f.currentToken.kind == Colon {
                next(f)
                if f.currentToken.kind == Rbrack {
                    end := next(f)
                    x = MakeSlice(f, begin, end, x, index, nil)
                    break
                }

                hi := parseExpr(f, false)
                end := expect(f, Rbrack)
                x = MakeSlice(f, begin, end, x, index, hi)
                break
            }
            end := expect(f, Rbrack)
            x = MakeSubscript(f, begin, end, x, index)
        case Lparen:
            begin := next(f)
            labels := []AstNode {}
            exprs := []AstNode {}
            if f.currentToken.kind != Rparen {
                labels, exprs = parseArgumentList(f)
            }
            end := next(f)
            return MakeCall(f, begin, end, labels, exprs)
        case Lbrace:
            if x.kind == ast.AstKind.FuncType {
                // TODO(Brett): error 'Unexpected '{' after function type'
                return x
            }
            return parseCompositeLiteralBody(f, x)
        case:
            return x
        }
    }

    return nil
}

stmtToStmtList :: fn(stmt: AstNode) -> []AstNode {
    stmts := []AstNode {}
    if stmt != nil {
        a := alloc.DefaultAllocatorInit()
        alloc.ArrayInit(a, &stmts, 1)
        alloc.Append(a, &stmts, stmt)
    }

    return stmts
}

tokenPrecedence :: fn(f: *SourceFile) -> u64 {
    switch using f.currentToken.kind {
    case Lor:
        return 1
    case Land:
        return 2
    case Eql, Neq, Lss, Leq, Gtr, Geq:
        return 3
    case Add, Sub, Or, Xor:
        return 4
    case Mul, Quo, Rem, Shl, Shr, And:
        return 5
    case:
        return LowestPrecedence
    }
}

tokenOperator :: fn(token: lex.Token) -> ast.Operator {
    using ast
    switch using token.kind {
    case Add, AssignAdd:
        return Operator.Add
    case Sub, AssignSub:
        return Operator.Sub
    case Mul, AssignMul:
        return Operator.Mul
    case Quo, AssignQuo:
        return Operator.Quo
    case Rem, AssignRem:
        return Operator.Rem
    case And, AssignAnd:
        return Operator.And
    case Or,  AssignOr:
        return Operator.Or
    case Xor, AssignXor:
        return Operator.Xor
    case Shl, AssignShl:
        return Operator.Shl
    case Shr, AssignShr:
        return Operator.Shr
    case:
        return Operator.Invalid
    }
}

allowTerm :: fn(f: *SourceFile) -> void {
    if f.currentToken.kind == lex.TokenKind.Semicolon
        next(f)
}

atComma :: fn(f: *SourceFile, token: lex.TokenKind, message: string) -> bool {
    if f.currentToken.kind == lex.TokenKind.Comma
        return true

    if f.currentToken.kind != token {
        if f.currentToken.kind == lex.TokenKind.Semicolon && strings.Compare(f.currentToken.lit, "\n") {
            next(f)
            if f.currentToken.kind == token return false
            // TODO(Brett): add before newline to warning
        }

        // TODO(Brett): report expected comma error
        return true
    }

    return false
}

expect :: fn(f: *SourceFile, token: lex.TokenKind) -> lex.Token {
    prev := f.currentToken
    if prev.kind != token {
        // TODO(Brett): error message
    }

    next(f)
    return prev
}

expectTerm :: fn(f: *SourceFile) -> void {
    switch using f.currentToken.kind {
        case Rparen, Rbrace: return
        case Comma:
            // TODO(Brett): error message
            fallthrough
        case Semicolon:
            next(f)
        case:
            // TODO(Brett): error message and recover
            next(f)
    }
}
