#import "lexer.kai" 

Token :: lexer.Token

Operator :: enum {
    Invalid,
    Add,
    Sub,
    Mul,
    Quo,
    Rem,
    And,
    Or,
    Xor,
    Shl,
    Shr
}

AstKind :: enum {
    BadExpr,
    Comment,
    StructField,
    EnumCase,
    LocationDirective,
    NilLiteral,
    Ident,
    Ellipsis,
    BasicLit,
    PolyParameterList,
    ResultList,
    IdentList,
    FuncLit,
    CompositeLit,
    Paren,
    Selector,
    Subscript,
    Slice,
    Autocast,
    Cast,
    Call,
    Unary,
    Binary,
    Ternary,
    KeyValue,
    PointerType,
    ArrayType,
    SliceType,
    VectorType,
    StructType,
    PolyStructType,
    EnumType,
    UnionType,
    VariantType,
    PolyType,
    VariadicType,
    FuncType,
    BadStmt,
    Empty,
    Label,
    ExprStmt,
    Assign,
    Return,
    Defer,
    Using,
    Branch,
    Block,
    If,
    CaseClause,
    Switch,
    For,
    ForIn,
    Import,
    Library,
    Foreign,
    DeclBlock,
    Declaration,
    BadDecl,
    FunctionSpecialization,
    StructSpecialization
}

AstNode :: struct {
    kind: AstKind
    ast: Ast
}

Ast :: union {
    BadExpr : struct { begin, end: Token }

    Comment : Token

    StructField : struct {}

    EnumCase : struct {}

    LocationDirective : struct {
        token: Token
        ident: []u8
    }

    NilLiteral : Token

    Ident : Token

    Ellipsis : struct {
        token: Token
        expr: *AstNode
    }

    BasicLit : Token

    PolyParameterList : struct {}

    ResultList : struct {}

    IdentList : struct {
        token: Token
        idents: []*AstNode
    }

    FuncLit : struct {
        token: Token
        type, 
        body: *AstNode
        flags: u8
    }

    CompositeLit : struct {
        begin,
        end: Token
        elements: []*AstNode
    }

    Paren : struct {
        begin, end: Token
        expr: *AstNode
    }

    Selector : struct {
        token: Token
        rec, sel: *AstNode
    }

    Subscript : struct {
        begin, end: Token
        rec,
        index: *AstNode
    }

    Slice : struct {
        begin, end: Token
        expr,
        lo,
        hi: *AstNode
    }

    Autocast : struct {
        token: Token
        expr: *AstNode
    }

    Cast : struct {
        kind: Token
        type,
        expr: *AstNode
    }

    Call : struct {
        begin,
        end: Token
        labels: []*AstNode
        args:   []*AstNode
    }

    Unary : struct {
        op: Token
        kind: Operator
        element: *AstNode
    }

    Binary : struct {
        op: Token
        kind: Operator
        lhs, rhs: *AstNode
    }

    Ternary : struct {
        qmark, colon: Token
        cond,
        then,
        els: *AstNode
    }

    KeyValue : struct {
        token: Token
        key,
        value: *AstNode
    }

    PointerType : struct {
        token: Token
        type: *AstNode
    }

    ArrayType : struct {
        begin, end: Token
        length,
        type: *AstNode
    }

    SliceType : struct {
        begin, end: Token
        type: *AstNode
    }

    VectorType : struct {
        begin, end: Token
        size,
        type: *AstNode
    }

    StructType : struct {}

    PolyStructType : struct {}

    EnumType : struct {}

    UnionType : struct {}

    VariantType : struct {}

    PolyType : struct {
        token: Token
        type: *AstNode
    }

    VariadicType : struct {
        token: Token
        type: *AstNode
        isCVargs: bool
    }

    FuncType : struct {}

    BadStmt : struct {
        begin, end: Token
    }

    Empty : Token

    Label : Token

    ExprStmt : struct {
        token: Token
        expr: *AstNode
    }

    Assign : struct {
        token: Token
        lhs,
        rhs: []*AstNode
    }

    Return: struct {
        token: Token
        stmts: []*AstNode
    }

    Defer: struct {
        token: Token
        stmt: *AstNode
    }

    Using: struct {
        token: Token
        expr: *AstNode
    }

    Branch: struct {
        token: Token
        label: *AstNode
    }

    Block : struct {
        begin, end: Token
        stmts: []*AstNode
    }

    If: struct {
        token: Token
        cond,
        body,
        els: *AstNode
    }

    CaseClause : struct {
        token: Token
        match: []*AstNode
        block: *AstNode
        // TODO(Brett): entity/label support
    }

    Switch: struct {
        token: Token
        match: *AstNode
        cases: []*AstNode
        // TODO(Brett): entity/label support
    }

    For: struct {
        token: Token
        init,
        cond,
        step,
        body: *AstNode
    }

    ForIn : struct {}

    Import: struct {}

    Library : struct {
        token: Token
        path,
        alias: *AstNode
    }

    Foreign : struct {
        token: Token
        library,
        decl: *AstNode
        linkname: []u8
        callconv: []u8
    }

    DeclBlock : struct {}

    Declaration : struct {
        token: Token
        names,
        values: []*AstNode
        type: *AstNode
        isConstant: bool
    }

    BadDecl : struct {
        begin, end: Token
    }

    FunctionSpecialization : struct {}

    StructSpecialization : struct {}
}

