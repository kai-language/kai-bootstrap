#import "libc.kai"

AllocType :: enum {
    ATAlloc,
    ATFree,
    ATFreeAll,
    ATRealloc
}

AllocFunc :: *(payload: rawptr, type: AllocType, size, oldsize: u64, old: rawptr) -> rawptr

Allocator :: struct {
    func: AllocFunc
    payload: rawptr
}

Arena :: struct {
    allocator: Allocator
    raw: []u8
}

// Initialize an 'Arena' using the default allocator.
ArenaInit :: fn(arena: *Arena, size: u64) -> void {
    ArenaInitFromAllocator(arena, DefaultAllocatorInit(), size)    
}

// Initialize an 'Arena' using a custom allocator.
ArenaInitFromAllocator :: fn(arena: *Arena, a: Allocator, size: u64) -> void {
    raw : []u8
    raw.raw = Alloc(a, size)
    raw.cap = size
    raw.len = 0
    arena.allocator = a
    arena.raw = raw
}

// An 'Arena'-based allocator.
ArenaAllocatorInit :: fn(arena: *Arena) -> Allocator {
    return Allocator {
        &arenaAllocFunc,
        arena
    }
}

// A 'malloc'-based allocator.
DefaultAllocatorInit :: fn() -> Allocator {
    return Allocator {
        &heapAllocFunc,
        nil
    }
}

arenaAllocFunc :: fn(payload: rawptr, type: AllocType, size, oldsize: u64, old: rawptr) -> rawptr {
    arena: *Arena = autocast payload

    using AllocType
    switch type {
    case ATAlloc: 
        if arena.raw.len + size > arena.raw.cap {
            return nil
        }
        ptr := &arena.raw[arena.raw.len]
        arena.raw.len += size
        return ptr
        
    case ATFree: fallthrough 
    case ATFreeAll: 
        arena.raw.len = 0
    case ATRealloc:
        return Realloc(arena.allocator, arena.raw.raw, oldsize, size)
    }

    return nil
}

heapAllocFunc :: fn(payload: rawptr, type: AllocType, size, oldsize: u64, old: rawptr) -> rawptr {
    using AllocType
    switch type {
    case ATAlloc:
        return libc.malloc(size)
    case ATFree:
        libc.free(old)
        return(nil) // FIXME: @CompilerBug 'return nil' derails parser
    case ATFreeAll: 
        break
    case ATRealloc:
        return libc.realloc(old, size)
    }

    return nil
}

// Allocates 'size' bytes and returns a raw pointer.
Alloc :: fn(a: Allocator, size: u64) -> rawptr {
    return a.func(a.payload, AllocType.ATAlloc, size, 0, nil)
}

// Frees up previously allocated memory.
Free :: fn(a: Allocator, ptr: rawptr) -> void {
    if ptr == nil return
    a.func(a.payload, AllocType.ATFree, 0, 0, ptr)
}

// Free up all items allocated by an 'Allocator'.
FreeAll :: fn(a: Allocator) -> void {
    a.func(a.payload, AllocType.ATFreeAll, 0, 0, nil)
}

Realloc :: fn(a: Allocator, ptr: rawptr, oldsize, size: u64) -> rawptr {
    return a.func(a.payload, AllocType.ATRealloc, size, oldsize, ptr)
}

