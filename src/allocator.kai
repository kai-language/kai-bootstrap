#import "libc.kai"

AllocType :: enum {
    Alloc,
    Free,
    FreeAll
}

AllocFunc :: *(payload: rawptr, type: AllocType, size: u64, old: rawptr) -> rawptr

Allocator :: struct {
    func: AllocFunc
    payload: rawptr
}

Arena :: struct {
    allocator: Allocator
    raw: []u8
}

InitArena :: fn(size: u64) -> Arena {
    raw : []u8
    raw.raw = libc.malloc(size)
    raw.cap = size 
    raw.len = 0
    return Arena {
        raw: raw
    }
}

InitArenaAllocator :: fn(arena: *Arena) -> Allocator {
    return Allocator {
        &arenaAllocFunc,
        arena
    }
}

arenaAllocFunc :: fn(payload: rawptr, type: AllocType, size: u64, old: rawptr) -> rawptr {
    arena: *Arena = autocast payload

    using AllocType
    switch type {
    case Alloc: 
        if arena.raw.len + size > arena.raw.cap {
            return nil
        }
        ptr := &arena.raw[arena.raw.len]
        arena.raw.len += size
        return ptr
        
    case Free: fallthrough 
    case FreeAll: 
        arena.raw.len = 0
    }

    return nil
}

// Allocates 'size' bytes and returns a raw pointer.
Alloc :: fn(a: Allocator, size: u64) -> rawptr {
    return a.func(a.payload, AllocType.Alloc, size, nil)
}

// Frees up previously allocated memory.
Free :: fn(a: Allocator, ptr: rawptr) -> void {
    if ptr == nil return
    a.func(a.payload, AllocType.Free, 0, ptr)
}

// Free up all items allocated by an 'Allocator'.
FreeAll :: fn(a: Allocator) -> void {
    a.func(a.payload, AllocType.FreeAll, 0, nil)
}

main :: fn() -> void {
    arena := InitArena(100000)
    alloc := InitArenaAllocator(&arena)
    Alloc(alloc, 10)
    Free(alloc, &arena)
}

