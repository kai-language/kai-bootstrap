Token :: enum {
    illegal,
    eof,
    comment,

    ident,
    directive,

    int,
    float,
    _string,

    add,
    sub,
    mul,
    quo,
    rem,

    and,
    or,
    xor,
    shl,
    shr,

    assignAdd,
    assignSub,
    assignMul,
    assignQuo,
    assignRem,
    
    assignAnd,
    assignOr,
    assignXor,
    assignShl,
    assignShr,

    land,
    lor,
    
    lss,
    gtr,
    not,

    eql,
    neq,
    leq,
    geq,

    assign,
    ellipsis,
    dollar,
    question,
    retArrow,

    lparen,
    lbrack,
    lbrace,
    rparen,
    rbrack,
    rbrace,

    comma,
    period,
    colon,
    semicolon,

    _cast,
    _bitcast,
    _autocast,

    _using,

    _goto,
    _break,
	_continue,
    _fallthrough,
   
    _return,

    _if,
    _for,
    _else,
    _defer,
    _in,
    _switch,
    _case,
    
    _fn,
    _union,
    _variant,
    _enum,
    _struct,

    _nil
}

Pos :: struct {
    fileno,
    offset: u32
}

Position :: struct {
    filename: string
    offset,
    line,
    column: u32
}

describeToken :: fn(tok: Token) -> string {
    switch tok {
	case Token.illegal:   return "<illegal>"
	case Token.eof:       return "<EOF>"
	case Token.comment:   return "<comment>"
	case Token.ident:     return "<ident>"
	case Token.directive: return "<directive>"
	case Token.int:       return "<int>"
	case Token.float:     return "<float>"
	case Token._string:    return "<string>"
	case Token.add:       return "+"
	case Token.sub:       return "-"
	case Token.mul:       return "*"
	case Token.quo:       return "/"
	case Token.rem:       return "%"
	case Token.and:       return "&"
	case Token.or:        return "|"
	case Token.xor:       return "^"
	case Token.shl:       return "<<"
	case Token.shr:       return ">>"
	case Token.land:      return "&&"
	case Token.lor:       return "||"
	case Token.lss:       return "<"
	case Token.gtr:       return ">"
	case Token.not:       return "!"
	case Token.eql:       return "=="
	case Token.neq:       return "!="
	case Token.leq:       return "<="
	case Token.geq:       return ">="
	case Token.assign:    return "="
	case Token.ellipsis:  return ".."
	case Token.dollar:    return "$"
	case Token.question:  return "?"
	case Token.retArrow:  return "->"
	case Token.lparen:    return "("
	case Token.lbrack:    return "["
	case Token.lbrace:    return "{"
	case Token.rparen:    return ")"
	case Token.rbrack:    return "]"
	case Token.rbrace:    return "}"
	case Token.comma:     return ","
	case Token.period:    return "."
	case Token.colon:     return ":"
	case Token.semicolon: return ";"
	case Token._cast:      return "cast"
	case Token._bitcast:   return "bitcast"
	case Token._autocast:  return "autocast"
	case Token._using:     return "using"
	case Token._goto:      return "goto"
	case Token._break:     return "break"
	case Token._continue:  return "continue"
	case Token._fallthrough: return "fallthrough"
	case Token._return:    return "return"
	case Token._if:        return "if"
	case Token._for:       return "for"
	case Token._else:      return "else"
	case Token._defer:     return "defer"
	case Token._in:        return "in"
	case Token._switch:    return "switch"
	case Token._case:      return "case"
	case Token._fn:        return "fn"
	case Token._union:     return "union"
	case Token._variant:   return "variant"
	case Token._enum:      return "enum"
	case Token._struct:    return "struct"
	case Token._nil:       return "nil"
    case: return "<unknown>"
    }
}

